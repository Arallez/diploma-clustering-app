<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>K-Means Simulator</title>
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0f172a;
            --sidebar-bg: #1e293b;
            --text-color: #e2e8f0;
            --accent-color: #3b82f6;
            --border-color: #334155;
            --success-color: #10b981;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .navbar {
            height: 60px;
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 24px;
            justify-content: space-between;
        }

        .navbar h1 { font-size: 18px; font-weight: 700; margin: 0; color: #fff; display: flex; align-items: center; gap: 10px; }
        .logo-icon { width: 24px; height: 24px; background: linear-gradient(135deg, #60a5fa, #a78bfa); border-radius: 6px; }

        .nav-links { display: flex; gap: 20px; }
        .nav-item { color: #94a3b8; text-decoration: none; font-size: 14px; font-weight: 500; transition: color 0.2s; }
        .nav-item:hover { color: #fff; }
        .nav-item.active { color: #fff; }

        .layout { display: flex; flex: 1; overflow: hidden; }

        .sidebar {
            width: 320px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            overflow-y: auto;
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .control-label { font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em; color: #64748b; font-weight: 600; }
        
        .btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s, transform 0.1s;
        }
        .btn:hover { opacity: 0.9; }
        .btn:active { transform: scale(0.98); }
        .btn-outline { background: transparent; border: 1px solid var(--border-color); color: var(--text-color); }
        .btn-outline:hover { background: rgba(255,255,255,0.05); }

        .cluster-input {
            background: #0f172a;
            border: 1px solid var(--border-color);
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            width: 60px;
            text-align: center;
        }

        .workspace { flex: 1; padding: 24px; display: flex; flex-direction: column; gap: 20px; }

        .stats-bar {
            display: flex;
            gap: 12px;
        }
        .stat-chip {
            background: var(--sidebar-bg);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            color: #94a3b8;
        }
        .stat-value { color: #fff; font-weight: 600; margin-left: 6px; }

        .graph-card {
            flex: 1;
            background: var(--sidebar-bg);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        #plot { width: 100%; height: 100%; background: var(--sidebar-bg); }

        .step-control {
            background: var(--sidebar-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .slider-container { flex: 1; display: flex; align-items: center; gap: 10px; }
        input[type=range] { flex: 1; cursor: pointer; }

        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s ease; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
    </style>
</head>
<body>

<!-- Vue App Wrapper -->
{% verbatim %}
<div id="app" style="display: flex; flex-direction: column; height: 100%;">
    
    <nav class="navbar">
        <h1><div class="logo-icon"></div> ML Simulator</h1>
        <div class="nav-links">
            <a href="#" class="nav-item active">Simulator</a>
            <a href="/simulator/tasks/" class="nav-item">Course</a>
            <a href="#" class="nav-item">Settings</a>
        </div>
    </nav>

    <div class="layout">
        <!-- Sidebar Controls -->
        <aside class="sidebar">
            <div class="control-group">
                <span class="control-label">Algorithm</span>
                <select class="cluster-input" style="width: 100%; text-align: left;">
                    <option>K-Means Clustering</option>
                    <option disabled>DBSCAN (Coming Soon)</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">Clusters (K)</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button class="btn btn-outline" @click="k > 1 ? k-- : null">-</button>
                    <input type="number" v-model="k" class="cluster-input" min="1" max="10">
                    <button class="btn btn-outline" @click="k < 10 ? k++ : null">+</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Actions</span>
                <button class="btn btn-outline" @click="clearPoints">Clear Board</button>
                <button class="btn" @click="runAlgorithm" :disabled="points.length === 0 || isRunning">
                    {{ isRunning ? 'Processing...' : 'Run Algorithm' }}
                </button>
            </div>

            <div style="margin-top: auto; padding: 16px; background: rgba(255,255,255,0.03); border-radius: 8px; font-size: 13px; color: #64748b; line-height: 1.5;">
                <strong>üí° How to use:</strong><br>
                1. Click anywhere on the empty graph area to add points.<br>
                2. Select number of clusters (K).<br>
                3. Press "Run" to see step-by-step clustering.
            </div>
        </aside>

        <!-- Main Workspace -->
        <main class="workspace">
            
            <!-- Info Chips -->
            <div class="stats-bar">
                <div class="stat-chip">Points: <span class="stat-value">{{ points.length }}</span></div>
                <div class="stat-chip">K-Value: <span class="stat-value">{{ k }}</span></div>
                <div class="stat-chip">Total Steps: <span class="stat-value">{{ history.length ? history.length : 0 }}</span></div>
            </div>

            <!-- Visualization -->
            <div class="graph-card">
                <!-- IMPORTANT: We attach a native click listener to the container -->
                <div id="plot" @click="handleCanvasClick"></div>
            </div>

            <!-- Step Player -->
            <transition name="fade">
                <div class="step-control" v-if="history.length > 0">
                    <button class="btn btn-outline" @click="setStep(0)">‚èÆ</button>
                    <button class="btn btn-outline" @click="prevStep">‚óÄ</button>
                    
                    <div class="slider-container">
                        <span style="font-size: 12px; color: #94a3b8; width: 40px; text-align: right;">{{ currentStep }}</span>
                        <input type="range" min="0" :max="history.length - 1" v-model.number="currentStep">
                        <span style="font-size: 12px; color: #94a3b8; width: 40px;">{{ history.length - 1 }}</span>
                    </div>

                    <button class="btn btn-outline" @click="nextStep">‚ñ∂</button>
                    <button class="btn btn-outline" @click="setStep(history.length - 1)">‚è≠</button>
                </div>
            </transition>

        </main>
    </div>

</div>
{% endverbatim %}

<script>
    const { createApp, ref, onMounted, watch } = Vue;

    createApp({
        setup() {
            const k = ref(3);
            const points = ref([]);
            const history = ref([]);
            const currentStep = ref(0);
            const isRunning = ref(false);

            const getBaseLayout = () => ({
                title: false,
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#94a3b8' },
                margin: { t: 20, b: 40, l: 40, r: 20 },
                xaxis: { range: [0, 10], gridcolor: '#334155', zerolinecolor: '#475569', fixedrange: true },
                yaxis: { range: [0, 10], gridcolor: '#334155', zerolinecolor: '#475569', fixedrange: true },
                showlegend: true,
                legend: { x: 0, y: 1, bgcolor: 'rgba(30,41,59,0.8)' },
                hovermode: false, 
                dragmode: false // Strict disable to prevent zoom interference
            });

            // Initialize Plotly
            const initPlot = () => {
                const plotDiv = document.getElementById('plot');
                if (!plotDiv) return;

                Plotly.newPlot('plot', [{
                    x: [], y: [], mode: 'markers', type: 'scatter', hoverinfo: 'none'
                }], getBaseLayout(), { 
                    displayModeBar: false, 
                    responsive: true,
                    staticPlot: false 
                });
            };

            // NATIVE DOM CLICK HANDLER - The most robust way to handle background clicks
            const handleCanvasClick = (event) => {
                // If algorithm has run, disable adding points
                if (history.value.length > 0) return;

                const plotDiv = document.getElementById('plot');
                
                // Ensure we are clicking on the drag layer (the interactive part) or the main svg
                // This prevents clicks on legend or other UI elements from adding points unexpectedly
                // 'ns-drag-layer' is Plotly's internal class for the interaction layer
                const isPlotCanvas = event.target.classList.contains('nsewdrag') || 
                                     event.target.classList.contains('drag') || 
                                     event.target.tagName === 'rect'; // Fallback for some SVG backgrounds
                
                // We use Plotly's internal axis mapping to get exact data coordinates
                // This works regardless of margins, padding, or screen size
                if (plotDiv && plotDiv._fullLayout) {
                    const xaxis = plotDiv._fullLayout.xaxis;
                    const yaxis = plotDiv._fullLayout.yaxis;
                    
                    // event.layerX/Y are relative to the element, but better to be safe
                    // Plotly typically handles pointer events well, but we need raw coordinates here
                    // p2d (pixel to data) requires coordinates relative to the axis bounding box
                    
                    // Simplest approach: let Plotly tell us where the mouse is
                    // But since this is a native click, we need to map manually.
                    
                    const rect = plotDiv.getBoundingClientRect();
                    const xPx = event.clientX - rect.left;
                    const yPx = event.clientY - rect.top;

                    // Use Plotly's internal function to map pixels to data
                    // Note: xaxis.p2d takes pixels relative to the plot area (inside margins)
                    // So we subtract the margin left/top
                    
                    const marginL = plotDiv._fullLayout.margin.l;
                    const marginT = plotDiv._fullLayout.margin.t;

                    let xVal = xaxis.p2d(xPx - marginL);
                    let yVal = yaxis.p2d(yPx - marginT);

                    // Clamp to range [0, 10]
                    if (xVal >= 0 && xVal <= 10 && yVal >= 0 && yVal <= 10) {
                        points.value.push([xVal, yVal]);
                        drawPoints();
                    }
                }
            };

            const drawPoints = () => {
                const trace = {
                    x: points.value.map(p => p[0]),
                    y: points.value.map(p => p[1]),
                    mode: 'markers',
                    type: 'scatter',
                    marker: { size: 10, color: '#e2e8f0', line: { color: '#000', width: 1 } },
                    name: 'Points',
                    hoverinfo: 'none'
                };
                Plotly.react('plot', [trace], getBaseLayout(), { displayModeBar: false });
            };

            const drawStep = (stepIndex) => {
                const stepData = history.value[stepIndex];
                if (!stepData) return;
                const traces = [];
                const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];

                stepData.clusters.forEach((clusterPoints, i) => {
                    if (clusterPoints.length > 0) {
                        traces.push({
                            x: clusterPoints.map(p => p[0]),
                            y: clusterPoints.map(p => p[1]),
                            mode: 'markers',
                            type: 'scatter',
                            name: `Cluster ${i+1}`,
                            marker: { size: 10, color: colors[i % colors.length] }
                        });
                    }
                });

                if (stepData.centroids && stepData.centroids.length > 0) {
                    traces.push({
                        x: stepData.centroids.map(c => c[0]),
                        y: stepData.centroids.map(c => c[1]),
                        mode: 'markers',
                        type: 'scatter',
                        name: 'Centroids',
                        marker: { symbol: 'x', size: 14, color: '#fff', line: { width: 3 } }
                    });
                }
                Plotly.react('plot', traces, getBaseLayout(), { displayModeBar: false });
            };

            const runAlgorithm = async () => {
                isRunning.value = true;
                try {
                    const response = await fetch('/simulator/api/run-kmeans/', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ points: points.value, k: k.value })
                    });
                    const data = await response.json();
                    if (data.success) {
                        history.value = data.history;
                        currentStep.value = 0;
                    } else {
                        alert('Error: ' + data.error);
                    }
                } catch (e) {
                    console.error(e);
                    alert('Server error');
                } finally {
                    isRunning.value = false;
                }
            };

            const nextStep = () => { if (currentStep.value < history.value.length - 1) currentStep.value++; };
            const prevStep = () => { if (currentStep.value > 0) currentStep.value--; };
            const setStep = (val) => { currentStep.value = val; };

            const clearPoints = () => {
                points.value = [];
                history.value = [];
                currentStep.value = 0;
                initPlot();
            };

            watch(currentStep, (newVal) => { if (history.value.length > 0) drawStep(newVal); });

            onMounted(() => {
                setTimeout(initPlot, 100);
            });

            return {
                k, points, history, currentStep, isRunning,
                runAlgorithm, nextStep, prevStep, setStep, clearPoints, handleCanvasClick
            };
        }
    }).mount('#app');
</script>

</body>
</html>
